<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>FPS Game</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: sans-serif;
    background: #87ceeb; /* Sky blue background */
    /* Prevent right-click context menu from appearing, useful for building */
    -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none;   /* Safari */
    -khtml-user-select: none;    /* Konqueror HTML */
    -moz-user-select: none;      /* Old versions of Firefox */
    -ms-user-select: none;       /* Internet Explorer/Edge */
    user-select: none;           /* Non-prefixed version, currently supported by Chrome, Edge, Opera and Firefox */
    -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
    touch-action: none; /* Disable browser touch actions for nipple.js */
  }
  #healthBarContainer {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 200px;
    height: 25px;
    background: #333;
    border: 2px solid #000;
    border-radius: 5px;
    z-index: 11;
  }
  #healthBar {
    width: 100%;
    height: 100%;
    background: #4caf50;
    border-radius: 3px;
    transition: width 0.3s ease;
  }
  #deathOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255, 0, 0, 0);
    pointer-events: none;
    transition: background 1s ease;
    z-index: 20;
  }
  #deathText {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 48px;
    font-weight: bold;
    opacity: 0;
    pointer-events: none;
    user-select: none;
    z-index: 21;
  }
  /* Inventory UI Styles */
  #inventoryContainer {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    padding: 10px;
    border-radius: 8px;
    display: flex;
    gap: 10px;
    z-index: 12;
  }
  .inventory-slot {
    width: 70px; /* Increased size for readability */
    height: 70px; /* Increased size for readability */
    background: rgba(255,255,255,0.2);
    border: 2px solid #555;
    border-radius: 5px;
    display: flex;
    flex-direction: column; /* Stack name and count */
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    user-select: none;
    text-align: center;
    padding: 2px;
  }
  .inventory-slot.active {
      border-color: #00ff00; /* Green highlight for active slot */
  }
  .item-name {
      font-size: 0.9em;
      line-height: 1.2;
  }
  .item-count {
      font-size: 0.8em;
      opacity: 0.8;
  }

  /* Message Display Styles */
  #messageDisplay {
    position: absolute;
    top: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    color: #fff;
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 18px;
    display: none;
    z-index: 15;
    white-space: nowrap; /* Prevent wrapping for messages */
  }

  /* Blood Splatter Overlay */
  #bloodOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 0, 0, 0); /* Start fully transparent */
    pointer-events: none; /* Allow interaction with elements behind it */
    z-index: 25; /* Above other UI elements */
    opacity: 0; /* Hidden by default */
    transition: opacity 0.1s ease-out, background-color 0.1s ease-out; /* Fast fade in */
  }

  #bloodOverlay.active {
    opacity: 0.4; /* Visible when active */
    background-color: rgba(255, 0, 0, 0.4);
  }
  #bloodOverlay.fade-out {
    opacity: 0; /* Fade out */
    transition: opacity 0.5s ease-in, background-color 0.5s ease-in; /* Slower fade out */
  }
  
  /* Touch Controls */
  #joystickLeft {
    position: absolute;
    bottom: 100px;
    left: 50px;
    width: 100px;
    height: 100px;
    z-index: 30;
    opacity: 0.7;
  }
  
  #joystickRight {
    position: absolute;
    bottom: 100px;
    right: 50px;
    width: 100px;
    height: 100px;
    z-index: 30;
    opacity: 0.7;
  }
  
  #jumpButton {
    position: absolute;
    bottom: 220px;
    right: 50px;
    width: 80px;
    height: 80px;
    background: rgba(0,0,0,0.3);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 16px;
    z-index: 30;
    opacity: 0.7;
    user-select: none;
  }
  
  #shootButton {
    position: absolute;
    bottom: 220px;
    right: 150px;
    width: 80px;
    height: 80px;
    background: rgba(255,0,0,0.3);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 16px;
    z-index: 30;
    opacity: 0.7;
    user-select: none;
  }
  
  @media (max-width: 768px) {
    #joystickLeft, #joystickRight {
      width: 80px;
      height: 80px;
      bottom: 80px;
    }
    #joystickLeft {
      left: 30px;
    }
    #joystickRight {
      right: 30px;
    }
    #jumpButton, #shootButton {
      width: 60px;
      height: 60px;
      bottom: 160px;
      font-size: 14px;
    }
    #jumpButton {
      right: 30px;
    }
    #shootButton {
      right: 110px;
    }
  }
</style>
</head>
<body>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="deathOverlay"></div>
<div id="deathText">You Died</div>

<div id="inventoryContainer"></div>
<div id="messageDisplay"></div>
<div id="bloodOverlay"></div>

<!-- Touch Controls -->
<div id="joystickLeft"></div>
<div id="joystickRight"></div>
<div id="jumpButton">JUMP</div>
<div id="shootButton">SHOOT</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<script>
  let camera, scene, renderer, controls;
  let velocity = new THREE.Vector3();
  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
  let canJump = false;
  let prevTime = performance.now();
  const bullets = [];
  const bulletSpeed = 50;
  const movementSpeed = 25; // Increased character speed (approx 1.25x the "normal" 20)
  const jumpBoostOnGroundShot = 15; // How much vertical velocity is added on ground shot
  const dampingFactor = 0.9; // For smoother deceleration

  const terrainSize = 200;
  const segments = 100;
  let terrainGeometry;
  let terrain;
  let grassTexture;

  const raycaster = new THREE.Raycaster();

  const trees = [];
  const treeCollisionRadius = 1.2;

  // Clouds
  const clouds = [];
  const numClouds = 20;
  const cloudSpeed = 5; // How fast clouds move
  const cloudSpawnRange = terrainSize * 1.5; // Wider range for clouds

  // Health variables
  const maxHealth = 100;
  let health = maxHealth;
  const healthBar = document.getElementById('healthBar');
  const deathOverlay = document.getElementById('deathOverlay');
  const deathText = document.getElementById('deathText');
  let isDead = false;

  // For fall damage calculation
  let fallingStartY = null;
  const bloodOverlay = document.getElementById('bloodOverlay');

  // --- Inventory System Variables ---
  const inventory = [];
  const inventorySize = 5; // Number of slots
  let activeInventorySlot = 0; // Currently selected slot (0-indexed)
  let messageTimeout; // To manage message display timeout

  // --- Building System Variables ---
  const buildDistance = 5; // Max distance to place or delete a block
  const gridSnap = 1; // Blocks will snap to a 1x1x1 grid
  let selectedBlockType = null; // The type of block currently selected for building
  const placedBlocks = []; // Array to store references to placed blocks

  // Define block properties (geometry and material)
  const blockTypes = {}; // Initialize empty, will be populated after texture load

  // --- Touch Controls Variables ---
  let joystickLeft, joystickRight;
  let lookX = 0, lookY = 0;
  let moveX = 0, moveY = 0;
  const lookSensitivity = 0.1;
  const moveSensitivity = 1.5;

  // --- Cloud class definition moved here to ensure it's defined before use ---
  class Cloud {
      constructor() {
          const geometry = new THREE.SphereGeometry(1, 8, 8); // Base sphere
          const material = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true });
          this.mesh = new THREE.Group(); // Group to hold multiple spheres for cloud shape

          const numSpheres = Math.floor(Math.random() * 5) + 3; // 3 to 7 spheres
          for (let i = 0; i < numSpheres; i++) {
              const sphere = new THREE.Mesh(geometry, material);
              sphere.position.x = (Math.random() - 0.5) * 4;
              sphere.position.y = (Math.random() - 0.5) * 2;
              sphere.position.z = (Math.random() - 0.5) * 4;
              sphere.scale.setScalar(Math.random() * 1.5 + 0.5); // Scale each sphere randomly
              sphere.castShadow = true;
              this.mesh.add(sphere);
          }
      }
  }
  // --- End of Cloud class definition ---

  // Call init() directly. animate() will be called inside init's texture load callback.
  init();

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue background

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Load texture before defining materials
    const loader = new THREE.TextureLoader();
    grassTexture = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', () => {
        // Set texture wrapping and repetition
        grassTexture.wrapS = THREE.RepeatWrapping;
        grassTexture.wrapT = THREE.RepeatWrapping;
        const textureRepeat = terrainSize / 2;
        grassTexture.repeat.set(textureRepeat, textureRepeat);

        // Once texture is loaded, define blockTypes and proceed with scene setup
        blockTypes.grass_block = {
            name: "Grass",
            geometry: new THREE.BoxGeometry(gridSnap, gridSnap, gridSnap),
            material: new THREE.MeshStandardMaterial({ map: grassTexture })
        };
        blockTypes.stone_block = {
            name: "Stone",
            geometry: new THREE.BoxGeometry(gridSnap, gridSnap, gridSnap),
            material: new THREE.MeshStandardMaterial({ color: 0x808080 }) // Gray
        };
        blockTypes.wood_block = {
            name: "Wood",
            geometry: new THREE.BoxGeometry(gridSnap, gridSnap, gridSnap),
            material: new THREE.MeshStandardMaterial({ color: 0x8B4513 }) // SaddleBrown
        };
        blockTypes.dirt_block = {
            name: "Dirt",
            geometry: new THREE.BoxGeometry(gridSnap, gridSnap, gridSnap),
            material: new THREE.MeshStandardMaterial({ color: 0x654321 }) // Brown
        };

        // --- Flat Terrain Generation ---
        terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);
        terrainGeometry.rotateX(-Math.PI / 2); // Lay it flat on the XZ plane

        // Ensure all Y are 0 for flat terrain
        for (let i = 0; i < terrainGeometry.attributes.position.count; i++) {
            terrainGeometry.attributes.position.setY(i, 0);
        }
        terrainGeometry.computeVertexNormals(); // Recalculate normals for flat surface

        // Terrain material using the loaded grass texture
        const terrainMaterial = new THREE.MeshStandardMaterial({ map: grassTexture });
        terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 200, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(100, 200, 100);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Add Clouds
        addClouds(numClouds);

        // Controls initialization
        controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        // Lock controls immediately to start the game
        controls.lock();

        // Player spawns slightly above the flat terrain (Y=0)
        controls.getObject().position.set(0, 1.8, 0); // Player height 1.8 above Y=0

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        document.addEventListener('mousedown', (event) => {
          if (!controls.isLocked || isDead) return;

          if (event.button === 0) { // Left click for shooting
              shootBullet();
          } else if (event.button === 2) { // Right click for building
              placeBlock();
          } else if (event.button === 1) { // Middle click for deleting (mouse wheel button)
              deleteBlock();
          }
        });

        // Disable context menu on right-click to prevent interference with building
        document.addEventListener('contextmenu', (event) => {
            if (controls.isLocked) { // Only disable if controls are locked (game active)
                event.preventDefault();
            }
        });

        document.addEventListener('wheel', onMouseWheel, { passive: false }); // For inventory scrolling, added passive: false

        window.addEventListener('resize', onWindowResize);

        // --- Initialize Inventory ---
        setupInventoryUI();
        addItemToInventory('grass_block', 10);
        addItemToInventory('stone_block', 5);
        addItemToInventory('wood_block', 3);
        addItemToInventory('dirt_block', 7);

        // --- Initialize Touch Controls ---
        setupTouchControls();

        // --- IMPORTANT: Start the animation loop AFTER all Three.js elements are initialized ---
        animate();
    }); // End of texture loader callback
  }

  // --- Touch Controls Setup ---
  function setupTouchControls() {
    // Left joystick for movement
    joystickLeft = nipplejs.create({
      zone: document.getElementById('joystickLeft'),
      mode: 'static',
      position: { left: '50%', top: '50%' },
      color: 'white',
      size: 80
    });
    
    joystickLeft.on('move', (evt, data) => {
      moveX = data.vector.x * moveSensitivity;
      moveY = data.vector.y * moveSensitivity;
    });
    
    joystickLeft.on('end', () => {
      moveX = 0;
      moveY = 0;
    });
    
    // Right joystick for looking around
    joystickRight = nipplejs.create({
      zone: document.getElementById('joystickRight'),
      mode: 'static',
      position: { left: '50%', top: '50%' },
      color: 'white',
      size: 80
    });
    
    joystickRight.on('move', (evt, data) => {
      lookX = data.vector.x * lookSensitivity;
      lookY = data.vector.y * lookSensitivity;
    });
    
    joystickRight.on('end', () => {
      lookX = 0;
      lookY = 0;
    });
    
    // Jump button
    const jumpButton = document.getElementById('jumpButton');
    jumpButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (canJump && controls.isLocked && !isDead) {
        velocity.y = 10;
        canJump = false;
      }
    });
    
    // Shoot button
    const shootButton = document.getElementById('shootButton');
    shootButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (controls.isLocked && !isDead) {
        shootBullet();
      }
    });
    
    // For building/deleting on touch devices, we'll need to add some UI
    // But for now, we'll just use long press on shoot button for building
    let buildTimeout;
    shootButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      buildTimeout = setTimeout(() => {
        if (controls.isLocked && !isDead) {
          placeBlock();
        }
      }, 500); // Long press for 500ms to build
    });
    
    shootButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      clearTimeout(buildTimeout);
    });
    
    // Show/hide touch controls based on device
    function updateControlVisibility() {
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints;
      const leftJoystick = document.getElementById('joystickLeft');
      const rightJoystick = document.getElementById('joystickRight');
      const jumpBtn = document.getElementById('jumpButton');
      const shootBtn = document.getElementById('shootButton');
      
      if (isTouchDevice) {
        leftJoystick.style.display = 'block';
        rightJoystick.style.display = 'block';
        jumpBtn.style.display = 'flex';
        shootBtn.style.display = 'flex';
      } else {
        leftJoystick.style.display = 'none';
        rightJoystick.style.display = 'none';
        jumpBtn.style.display = 'none';
        shootBtn.style.display = 'none';
      }
    }
    
    // Initial update and on resize
    updateControlVisibility();
    window.addEventListener('resize', updateControlVisibility);
  }

  // --- Cloud Generation ---
  function addClouds(amount) {
      for (let i = 0; i < amount; i++) {
          const cloud = new Cloud();
          cloud.mesh.position.x = (Math.random() - 0.5) * cloudSpawnRange;
          cloud.mesh.position.y = 50 + Math.random() * 30; // High in the sky
          cloud.mesh.position.z = (Math.random() - 0.5) * cloudSpawnRange;
          scene.add(cloud.mesh);
          clouds.push(cloud.mesh);
      }
  }

  function animateClouds(delta) {
      clouds.forEach(cloud => {
          cloud.position.x += cloudSpeed * delta; // Move clouds along X-axis
          // Wrap around if they go off screen
          if (cloud.position.x > cloudSpawnRange / 2) {
              cloud.position.x = -cloudSpawnRange / 2;
          }
      });
  }

  // --- Inventory System Functions ---
  function setupInventoryUI() {
      const invContainer = document.getElementById('inventoryContainer');
      for (let i = 0; i < inventorySize; i++) {
          const slot = document.createElement('div');
          slot.className = 'inventory-slot';
          slot.dataset.slotIndex = i;
          const itemNameDiv = document.createElement('div');
          itemNameDiv.className = 'item-name';
          const itemCountDiv = document.createElement('div');
          itemCountDiv.className = 'item-count';
          slot.appendChild(itemNameDiv);
          slot.appendChild(itemCountDiv);
          invContainer.appendChild(slot);
          inventory.push({ type: null, count: 0 }); // Initialize inventory with empty slots
      }
      updateInventoryUI();
  }

  function updateInventoryUI() {
      const slots = document.querySelectorAll('.inventory-slot');
      slots.forEach((slot, index) => {
          const item = inventory[index];
          const itemNameDiv = slot.querySelector('.item-name');
          const itemCountDiv = slot.querySelector('.item-count');

          if (item.count > 0 && blockTypes[item.type]) {
              itemNameDiv.textContent = blockTypes[item.type].name;
              itemCountDiv.textContent = `(${item.count})`;
          } else {
              itemNameDiv.textContent = '';
              itemCountDiv.textContent = '';
          }
          
          if (index === activeInventorySlot) {
              slot.classList.add('active');
          } else {
              slot.classList.remove('active');
          }
      });
      selectedBlockType = inventory[activeInventorySlot].type; // Update selected block type
      showMessage(`Selected: ${selectedBlockType ? blockTypes[selectedBlockType].name : 'None'}`, 1000);
  }

  function addItemToInventory(type, count = 1) {
      if (!blockTypes[type]) {
          console.warn(`Attempted to add unknown block type: ${type}`);
          return false;
      }

      for (let i = 0; i < inventorySize; i++) {
          if (inventory[i].type === type) {
              inventory[i].count += count;
              updateInventoryUI();
              showMessage(`Added ${count} ${blockTypes[type].name}(s)`, 1000);
              return true;
          }
      }
      for (let i = 0; i < inventorySize; i++) {
          if (inventory[i].type === null) {
              inventory[i] = { type: type, count: count };
              updateInventoryUI();
              showMessage(`Added ${count} ${blockTypes[type].name}(s)`, 1000); 
              return true;
          }
      }
      showMessage("Inventory full!", 1000);
      return false;
  }

  function removeItemFromInventory(type, count = 1) {
      for (let i = 0; i < inventorySize; i++) {
          if (inventory[i].type === type) {
              inventory[i].count -= count;
              if (inventory[i].count <= 0) {
                  inventory[i] = { type: null, count: 0 };
              }
              updateInventoryUI();
              return true;
          }
      }
      return false;
  }

  function onMouseWheel(event) {
      if (!controls.isLocked || isDead) return;
      event.preventDefault(); // Prevent page scrolling

      if (event.deltaY < 0) { // Scroll up (previous slot)
          activeInventorySlot = (activeInventorySlot - 1 + inventorySize) % inventorySize;
      } else { // Scroll down (next slot)
          activeInventorySlot = (activeInventorySlot + 1) % inventorySize;
      }
      updateInventoryUI();
  }

  function showMessage(msg, duration = 1500) {
      const msgDisplay = document.getElementById('messageDisplay');
      msgDisplay.innerText = msg;
      msgDisplay.style.display = 'block';
      if (messageTimeout) clearTimeout(messageTimeout);
      messageTimeout = setTimeout(() => {
          msgDisplay.style.display = 'none';
      }, duration);
  }

  // --- Building System Function ---
  function placeBlock() {
      if (!selectedBlockType || inventory[activeInventorySlot].count === 0) {
          showMessage("No block selected or not enough blocks!", 1000);
          return;
      }

      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // Raycast from center of screen

      // Intersect with terrain and all placed blocks
      const objectsToIntersect = [terrain, ...placedBlocks];
      const intersects = raycaster.intersectObjects(objectsToIntersect);

      if (intersects.length > 0) {
          const intersect = intersects[0];
          if (intersect.distance <= buildDistance) {
              const normal = intersect.face.normal;
              let position = intersect.point.clone().add(normal.multiplyScalar(gridSnap / 2));

              // Snap to grid
              position.x = Math.round(position.x / gridSnap) * gridSnap;
              position.y = Math.round(position.y / gridSnap) * gridSnap;
              position.z = Math.round(position.z / gridSnap) * gridSnap;

              // Ensure Y is at least half a block above Y=0 (ground level)
              position.y = Math.max(gridSnap / 2, position.y);


              // Player collision check to prevent placing block inside player
              const playerHeight = 1.8;
              const playerWidth = 0.8; // Player is not a perfect sphere, use approximate width
              const playerDepth = 0.8;

              const playerMinX = controls.getObject().position.x - playerWidth / 2;
              const playerMaxX = controls.getObject().position.x + playerWidth / 2;
              const playerMinY = controls.getObject().position.y;
              const playerMaxY = playerMinY + playerHeight;
              const playerMinZ = controls.getObject().position.z - playerDepth / 2;
              const playerMaxZ = controls.getObject().position.z + playerDepth / 2;

              const blockMinX = position.x - gridSnap / 2;
              const blockMaxX = position.x + gridSnap / 2;
              const blockMinY = position.y - gridSnap / 2;
              const blockMaxY = position.y + gridSnap / 2;
              const blockMinZ = position.z - gridSnap / 2;
              const blockMaxZ = position.z + gridSnap / 2;

              const playerCollidesWithBlock = (
                  playerMinX < blockMaxX && playerMaxX > blockMinX &&
                  playerMinY < blockMaxY && playerMaxY > blockMinY &&
                  playerMinZ < blockMaxZ && playerMaxZ > blockMinZ
              );

              if (playerCollidesWithBlock) {
                  showMessage("Cannot place block inside player!", 1000);
                  return;
              }

              // Check for existing block at target position to prevent overlapping
              const existingBlock = placedBlocks.find(block =>
                  block.position.x === position.x &&
                  block.position.y === position.y &&
                  block.position.z === position.z
              );

              if (existingBlock) {
                  showMessage("Block already exists here!", 1000);
                  return;
              }

              // Create and add the new block
              const blockProps = blockTypes[selectedBlockType];
              // For textured blocks, clone the material to prevent shared texture issues
              const newBlockMaterial = blockProps.material.isMaterial ? blockProps.material.clone() : new THREE.MeshStandardMaterial({ color: blockProps.material.color });
              if (blockProps.material.map) {
                  newBlockMaterial.map = blockProps.material.map;
              }
              
              const newBlock = new THREE.Mesh(blockProps.geometry, newBlockMaterial);
              newBlock.position.copy(position);
              newBlock.castShadow = true;
              newBlock.receiveShadow = true;
              newBlock.userData.type = selectedBlockType; // Store block type for deletion
              scene.add(newBlock);
              placedBlocks.push(newBlock);

              removeItemFromInventory(selectedBlockType, 1);
              showMessage(`Placed ${blockTypes[selectedBlockType].name}`, 500);
          } else {
              showMessage("Too far to place block!", 1000);
          }
      } else {
          showMessage("Can't place block there!", 1000);
      }
  }

  // --- Deletion System Function ---
  function deleteBlock() {
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // Raycast from center of screen

      // Only intersect with placed blocks for deletion
      const intersects = raycaster.intersectObjects(placedBlocks);

      if (intersects.length > 0) {
          const intersect = intersects[0];
          if (intersect.distance <= buildDistance) { // Check if block is within deletion range
              const blockToDelete = intersect.object;

              // Remove from scene and from our placedBlocks array
              scene.remove(blockToDelete);
              const index = placedBlocks.indexOf(blockToDelete);
              if (index > -1) {
                  placedBlocks.splice(index, 1);
              }

              // Return item to inventory
              const blockType = blockToDelete.userData.type; // Retrieve original type
              if (blockType && addItemToInventory(blockType, 1)) {
                  showMessage(`Deleted ${blockTypes[blockType].name} (returned to inventory)`, 500);
              } else {
                  showMessage(`Deleted ${blockTypes[blockType].name} (inventory full!)`, 500);
              }
          } else {
              showMessage("Too far to delete block!", 1000);
          }
      } else {
          showMessage("No block found to delete!", 1000);
      }
  }

  // --- Game Core Functions ---

  function shootBullet() {
    const startPos = controls.getObject().position.clone();
    const shootDir = new THREE.Vector3();
    camera.getWorldDirection(shootDir);

    raycaster.set(startPos, shootDir);

    // Can intersect with terrain or blocks for bullet impact logic
    const objectsToHit = [terrain, ...placedBlocks];
    const intersects = raycaster.intersectObjects(objectsToHit);

    if (intersects.length > 0) {
        const intersect = intersects[0];
        // Check if the shot hit the terrain or a block directly below (or slightly in front/below)
        // Adjust the angle/normal check based on how precise you want the "rocket jump" to be.
        // Here, we check if the normal points somewhat upward, suggesting a ground hit.
        // Or if the object is the terrain itself, it's a ground hit.
        if (intersect.object === terrain || intersect.face.normal.y > 0.5) { // Normal.y > 0.5 means it's mostly flat or upward facing
            velocity.y = jumpBoostOnGroundShot; // Apply upward force
            canJump = false; // Player is now airborne from shot
            return; // Don't create a visual bullet for ground impacts
        }
    }

    // Default bullet behavior if no ground/block is hit or if it's not a "ground shot"
    const bulletGeo = new THREE.SphereGeometry(0.05, 8, 8);
    const bulletMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const bullet = new THREE.Mesh(bulletGeo, bulletMat);
    bullet.position.copy(startPos);
    scene.add(bullet);
    bullets.push({ mesh: bullet, direction: shootDir.clone() });
  }

  // Adjusted for flat terrain and block collision
  function checkTreeCollision(newPos) {
    const playerWidth = 0.8;
    const playerDepth = 0.8;
    const playerHalfWidth = playerWidth / 2;
    const playerHalfDepth = playerDepth / 2;

    for (const block of placedBlocks) {
        const blockHalf = gridSnap / 2;
        // Check for AABB collision in XZ plane
        if (newPos.x + playerHalfWidth > block.position.x - blockHalf &&
            newPos.x - playerHalfWidth < block.position.x + blockHalf &&
            newPos.z + playerHalfDepth > block.position.z - blockHalf &&
            newPos.z - playerHalfDepth < block.position.z + blockHalf) {

            // Check if player's Y level overlaps with block's Y level
            const playerFeetY = controls.getObject().position.y;
            const playerHeadY = playerFeetY + 1.8; // Player height
            const blockBottomY = block.position.y - blockHalf;
            const blockTopY = block.position.y + blockHalf;

            if (playerHeadY > blockBottomY && playerFeetY < blockTopY) {
                return true; // Collision detected
            }
        }
    }
    return false;
  }

  function onKeyDown(event) {
    if (isDead || !controls.isLocked) return;
    switch(event.code) {
      case 'KeyW': moveForward = true; break;
      case 'KeyS': moveBackward = true; break;
      case 'KeyA': moveLeft = true; break;
      case 'KeyD': moveRight = true; break;
      case 'Space':
        if (canJump) {
          velocity.y = 10;
          canJump = false;
        }
        break;
    }
  }

  function onKeyUp(event) {
    if (isDead || !controls.isLocked) return;
    switch(event.code) {
      case 'KeyW': moveForward = false; break;
      case 'KeyS': moveBackward = false; break;
      case 'KeyA': moveLeft = false; break;
      case 'KeyD': moveRight = false; break;
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function applyFallDamage(fallDistance) {
    // A little more forgiving: start damaging after 4 units fall, 6 damage per unit after that.
    const damage = Math.max(0, (fallDistance - 4) * 6);
    if (damage > 0) {
      health -= damage;
      if (health < 0) health = 0;
      updateHealthBar();
      showBloodEffect(); // New: Show blood animation
      if (health === 0) {
        onDeath();
      }
    }
  }

  // New: Function to show blood splatter animation
  function showBloodEffect() {
      bloodOverlay.classList.remove('fade-out'); // Remove fade-out class if present
      bloodOverlay.classList.add('active'); // Activate blood overlay

      setTimeout(() => {
          bloodOverlay.classList.remove('active'); // Deactivate after short delay
          bloodOverlay.classList.add('fade-out'); // Start fade-out animation
      }, 100); // How long the blood is visible at full opacity (100ms)

      // Ensure fade-out class is removed after its transition completes
      setTimeout(() => {
          bloodOverlay.classList.remove('fade-out');
      }, 600); // 100ms (active duration) + 500ms (fade-out transition)
  }

  function updateHealthBar() {
    healthBar.style.width = (health / maxHealth * 100) + '%';
    if (health > 60) healthBar.style.background = '#4caf50';
    else if (health > 30) healthBar.style.background = '#ff9800';
    else healthBar.style.background = '#f44336';
  }

  function onDeath() {
    isDead = true;
    deathOverlay.style.pointerEvents = 'auto';
    deathOverlay.style.background = 'rgba(255,0,0,0.6)';
    deathText.style.opacity = 1;
    controls.unlock();
  }

  function resetGame() {
    isDead = false;
    health = maxHealth;
    updateHealthBar();
    deathOverlay.style.background = 'rgba(255,0,0,0)';
    deathText.style.opacity = 0;
    controls.getObject().position.set(0, 1.8, 0); // Reset to fixed flat ground height
    velocity.set(0,0,0);
    moveForward = moveBackward = moveLeft = moveRight = false;
    canJump = true;
    fallingStartY = null;

    // Clear all placed blocks from the scene and array
    placedBlocks.forEach(block => scene.remove(block));
    placedBlocks.length = 0;

    // Reset inventory
    for(let i=0; i<inventorySize; i++) {
        inventory[i] = { type: null, count: 0 };
    }
    addItemToInventory('grass_block', 10);
    addItemToInventory('stone_block', 5);
    addItemToInventory('wood_block', 3);
    addItemToInventory('dirt_block', 7);
  }

  // Adjust getHeightAt to consider placed blocks on a flat base terrain (Y=0)
  function getHeightAt(x, z) {
      let groundLevel = 0; // Base terrain is always at Y=0

      let highestBlockY = -Infinity;

      for (const block of placedBlocks) {
          const blockHalf = gridSnap / 2;
          // Check if the XZ coordinates are within the block's XZ bounds
          if (x >= block.position.x - blockHalf && x < block.position.x + blockHalf &&
              z >= block.position.z - blockHalf && z < block.position.z + blockHalf) {
              
              const blockTopY = block.position.y + blockHalf;
              if (blockTopY > highestBlockY) {
                  highestBlockY = blockTopY;
              }
          }
      }
      // The player's standing height will be the highest block's top + player height,
      // or the ground level (0) + player height, whichever is higher.
      return Math.max(groundLevel, highestBlockY);
  }


  function animate() {
    requestAnimationFrame(animate);

    if (controls.isLocked && !isDead) {
      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      // Apply damping to current velocity
      velocity.x *= dampingFactor;
      velocity.z *= dampingFactor;

      // --- Handle touch controls for looking ---
      if (Math.abs(lookX) > 0.1 || Math.abs(lookY) > 0.1) {
        // Rotate camera based on joystick input
        controls.getObject().rotation.y -= lookX * 0.02;
        camera.rotation.x -= lookY * 0.02;
        
        // Clamp vertical look to prevent over-rotation
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
      }

      // --- Handle touch controls for movement ---
      if (Math.abs(moveX) > 0.1 || Math.abs(moveY) > 0.1) {
        // Convert joystick input to movement direction
        const angle = Math.atan2(moveX, moveY);
        const moveForwardTouch = Math.cos(angle) * Math.sqrt(moveX * moveX + moveY * moveY);
        const moveRightTouch = Math.sin(angle) * Math.sqrt(moveX * moveX + moveY * moveY);
        
        // Set movement flags based on joystick input
        moveForward = moveForwardTouch > 0.5;
        moveBackward = moveForwardTouch < -0.5;
        moveLeft = moveRightTouch < -0.5;
        moveRight = moveRightTouch > 0.5;
      } else {
        // Reset movement if joystick is centered
        moveForward = moveBackward = moveLeft = moveRight = false;
      }

      // --- Calculate horizontal movement based on camera's *horizontal* direction ---
      const forwardDirection = new THREE.Vector3();
      camera.getWorldDirection(forwardDirection);
      forwardDirection.y = 0; // Crucial: Zero out the Y component to only get horizontal direction
      forwardDirection.normalize(); // Ensure it's a unit vector

      const rightDirection = new THREE.Vector3();
      rightDirection.crossVectors(camera.up, forwardDirection); // Get the rightward vector
      rightDirection.y = 0; // Crucial: Zero out Y component for horizontal right
      rightDirection.normalize();

      // Apply input-based acceleration to horizontal velocity only
      if (moveForward) velocity.addScaledVector(forwardDirection, movementSpeed * delta); // Move along forwardDirection
      if (moveBackward) velocity.addScaledVector(forwardDirection, -movementSpeed * delta);
      if (moveLeft) velocity.addScaledVector(rightDirection, -movementSpeed * delta); // Move along -rightDirection
      if (moveRight) velocity.addScaledVector(rightDirection, movementSpeed * delta);

      // Limit horizontal velocity to prevent super-speeding due to accumulation
      velocity.x = Math.max(-movementSpeed, Math.min(movementSpeed, velocity.x));
      velocity.z = Math.max(-movementSpeed, Math.min(movementSpeed, velocity.z));


      velocity.y -= 25 * delta; // Gravity

      const oldPos = controls.getObject().position.clone();

      // Apply movement using the accumulated velocity
      controls.getObject().position.x += velocity.x * delta;
      controls.getObject().position.z += velocity.z * delta;


      // Check for horizontal collisions after movement
      // (Your existing checkTreeCollision should work fine here as it uses XZ)
      const currentHorizontalPos = controls.getObject().position.clone();
      currentHorizontalPos.y = oldPos.y; // Keep old Y for collision check
      if (checkTreeCollision(currentHorizontalPos)) {
          controls.getObject().position.x = oldPos.x;
          controls.getObject().position.z = oldPos.z;
          velocity.x = 0;
          velocity.z = 0;
      }

      // Apply vertical movement (jump/gravity)
      controls.getObject().position.y += velocity.y * delta;

      // Calculate the effective ground height at the player's current XZ position
      const playerHeightStanding = 1.8;
      const actualGroundY = getHeightAt(controls.getObject().position.x, controls.getObject().position.z);
      const playerTargetY = actualGroundY + playerHeightStanding;

      // Ground collision and snapping
      if (controls.getObject().position.y <= playerTargetY) { // Use <= to catch floating point inaccuracies
        if (fallingStartY !== null) {
          const fallDist = fallingStartY - controls.getObject().position.y;
          applyFallDamage(fallDist);
          fallingStartY = null;
        }

        velocity.y = 0;
        controls.getObject().position.y = playerTargetY;
        canJump = true;
      } else {
        // Player is in the air (jumping or falling)
        // If just started falling, record the starting Y position
        if (velocity.y < 0 && fallingStartY === null) {
          fallingStartY = controls.getObject().position.y;
        }
      }

      // Bullet animation (rest of your bullet code)
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.direction, bulletSpeed * delta);

        if (b.mesh.position.distanceTo(controls.getObject().position) > 100 || b.mesh.position.y < (getHeightAt(b.mesh.position.x, b.mesh.position.z) - 5)) {
          scene.remove(b.mesh);
          bullets.splice(i, 1);
        }
      }

      // Animate clouds
      animateClouds(delta);

      prevTime = time;
    }

    renderer.render(scene, camera);
  }
</script>
</body>
</html>
